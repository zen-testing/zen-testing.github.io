---
title: 'kill命令参数及用法详解'
date: 2022-09-26 17:18:27
tags: [Linux]
published: true
hideInList: false
feature: 
isTop: false
---

>功能说明:删除执行中的程序或工作

# 语法

```shell
kill [-s <信息名称或编号>][程序]　或　kill [-l <信息编号>]
kill [ －s signal | －p ] [ －a ] pid …
kill －l [ signal ]
```


# 补充说明

kill可将指定的信息送至程序预设的信息为SIGTERM(15),可将指定程序终止若仍无法终止该程序,可使用SIGKILL(9)信息尝试强制删除程序程序或工作的编号可利用ps指令或jobs指令查看

# 参数
|||
|:---|---:|
|－s|指定发送的信号|
|－p|模拟发送信号|
|－l|指定信号的名称列表|
|pid|要中止进程的ID号|
|Signal|表示信号|

# 说明

进程是Linux系统中一个非常重要的概念Linux是一个多任务的操作系统,系统上经常同时运行着多个进程我们不关心这些进程究竟是如何分配的,或者是内核如何管理分配时间片的,所关心的是如何去控制这些进程,让它们能够很好地为用户服务

Linux操作系统包括三种不同类型的进程,每种进程都有自己的特点和属性交互进程是由一个Shell启动的进程交互进程既可以在前台运行,也可以在后台运行批处理进程和终端没有联系,是一个进程序列监控进程(也称系统守护进程)是Linux系统启动时启动的进程,并在后台运行例如,httpd 是著名的Apache服务器的监控进程

kill命令的工作原理是,向Linux系统的内核发送一个系统操作信号和某个程序的进程标识号,然后系统内核就可以对进程标识号指定的进程进行操作比如在top命令中,我们看到系统运行许多进程,有时就需要使用kill中止某些进程来提高系统资源在讲解安装和登陆命令时,曾提到系统多个虚拟控制台的作用是当一个程序出错造成系统死锁时,可以切换到其它虚拟控制台工作关闭这个程序此时使用的命令就是kill,因为kill是大多数Shell内部命令可以直接调用的

# kill 信号列表

||||
|:---|---|---:|
|1|SIGHUP|本信号在用户终端连接(正常或非正常)结束时发出, 通常是在终端的控制进程结束时, 通知同一session内的各个作业, 这时它们与控制终端不再关联<br>登录Linux时,系统会分配给登录用户一个终端(Session)在这个终端运行的所有程序,包括前台进程组和后台进程组,一般都属于这个 Session当用户退出Linux登录时,前台进程组和后台有对终端输出的进程将会收到SIGHUP信号这个信号的默认操作为终止进程,因此前台进 程组和后台有终端输出的进程就会中止不过可以捕获这个信号,比如wget能捕获SIGHUP信号,并忽略它,这样就算退出了Linux登录,wget也 能继续下载<br>此外,对于与终端脱离关系的守护进程,这个信号用于通知它重新读取配置文件|
|2|SIGINT|程序终止(interrupt)信号, 在用户键入INTR字符(通常是Ctrl-C)时发出,用于通知前台进程组终止进程|
|3|SIGQUIT|和SIGINT类似, 但由QUIT字符(通常是Ctrl-)来控制 进程在因收到SIGQUIT退出时会产生core文件, 在这个意义上类似于一个程序错误信号|
|4|SIGILL|执行了非法指令 通常是因为可执行文件本身出现错误, 或者试图执行数据段 堆栈溢出时也有可能产生这个信号|
|5|SIGTRAP|由断点指令或其它trap指令产生 由debugger使用|
|6|SIGABRT|调用abort函数生成的信号|
|7|SIGBUS|非法地址, 包括内存地址对齐(alignment)出错比如访问一个四个字长的整数, 但其地址不是4的倍数它与SIGSEGV的区别在于后者是由于对合法存储地址的非法访问触发的(如访问不属于自己存储空间或只读存储空间)|
|8|SIGFPE|在发生致命的算术运算错误时发出 不仅包括浮点运算错误, 还包括溢出及除数为0等其它所有的算术的错误|
|9|SIGKILL|用来立即结束程序的运行 本信号不能被阻塞\处理和忽略如果管理员发现某个进程终止不了,可尝试发送这个信号|
|10|SIGUSR1|留给用户使用|
|11|SIGSEGV|试图访问未分配给自己的内存, 或试图往没有写权限的内存地址写数据|
|12|SIGUSR2|留给用户使用|
|13|SIGPIPE|管道破裂这个信号通常在进程间通信产生,比如采用FIFO(管道)通信的两个进程,读管道没打开或者意外终止就往管道写,写进程会收到SIGPIPE信号此外用Socket通信的两个进程,写进程在写Socket的时候,读进程已经终止|
|14|SIGALRM|时钟定时信号, 计算的是实际的时间或时钟时间 alarm函数使用该信号|
|15|SIGTERM|程序结束(terminate)信号,与SIGKILL不同的是该信号可以被阻塞和处理通常用来要求程序自己正常退出,shell命令kill缺省产生这个信号如果进程终止不了,我们才会尝试SIGKILL|
|16|SIGSTKFLT||
|17|SIGCHLD|子进程结束时,父进程会收到这个信号<br>如果父进程没有处理这个信号,也没有等待(wait)子进程,子进程虽然终止,但是还会在内核进程表中占有表项,这时的子进程称为僵尸进程这种情 况我们应该避免(父进程或者忽略SIGCHILD信号,或者捕捉它,或者wait它派生的子进程,或者父进程先终止,这时子进程的终止自动由init进程来接管)|
|18|SIGCONT|让一个停止(stopped)的进程继续执行 本信号不能被阻塞 可以用一个handler来让程序在由stopped状态变为继续执行时完成特定的工作例如, 重新显示提示符|
|19|SIGSTOP|停止(stopped)进程的执行 注意它和terminate以及interrupt的区别:该进程还未结束, 只是暂停执行 本信号不能被阻塞, 处理或忽略|
|20|SIGTSTP|停止进程的运行, 但该信号可以被处理和忽略 用户键入SUSP字符时(通常是Ctrl-Z)发出这个信号|
|21|SIGTTIN|当后台作业要从用户终端读数据时, 该作业中的所有进程会收到SIGTTIN信号 缺省时这些进程会停止执行|
|22|SIGTTOU|类似于SIGTTIN, 但在写终端(或修改终端模式)时收到|
|23|SIGURG|有"紧急"数据或out-of-band数据到达socket时产生|
|24|SIGXCPU|超过CPU时间资源限制 这个限制可以由getrlimit/setrlimit来读取/改变|
|25|SIGXFSZ|当进程企图扩大文件以至于超过文件大小资源限制|
|26|SIGVTALRM|虚拟时钟信号 类似于SIGALRM, 但是计算的是该进程占用的CPU时间|
|27|SIGPROF|类似于SIGALRM/SIGVTALRM, 但包括该进程用的CPU时间以及系统调用的时间|
|28|SIGWINCH|窗口大小改变时发出|
|29|SIGIO|文件描述符准备就绪, 可以开始进行输入/输出操作|
|30|SIGPWR|Power failure|
|31|SIGSYS|非法的系统调用|
|32|||
|33|||
|34|SIGRTMIN||
|35|SIGRTMIN+1||
|36|SIGRTMIN+2||
|37|SIGRTMIN+3||
|38|SIGRTMIN+4||
|39|SIGRTMIN+5||
|40|SIGRTMIN+6||
|41|SIGRTMIN+7||
|42|SIGRTMIN+8||
|43|SIGRTMIN+9||
|44|SIGRTMIN+10||
|45|SIGRTMIN+11||
|46|SIGRTMIN+12||
|47|SIGRTMIN+13||
|48|SIGRTMIN+14||
|49|SIGRTMIN+15||
|50|SIGRTMAX-14||
|51|SIGRTMAX-13||
|52|SIGRTMAX-12||
|53|SIGRTMAX-11||
|54|SIGRTMAX-10||
|55|SIGRTMAX-9||
|56|SIGRTMAX-8||
|57|SIGRTMAX-7||
|58|SIGRTMAX-6||
|59|SIGRTMAX-5||
|60|SIGRTMAX-4||
|61|SIGRTMAX-3||
|62|SIGRTMAX-2||
|63|SIGRTMAX-1||
|64|SIGRTMAX||